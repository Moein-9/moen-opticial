
// This file is automatically generated. Do not edit it directly.
import { create } from '@supabase/supabase-js';
import type { Database } from './types';

const SUPABASE_URL = "https://loxnmnlszxxjrpkfybwm.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImxveG5tbmxzenh4anJwa2Z5YndtIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDM0NDgzMTEsImV4cCI6MjA1OTAyNDMxMX0.Xs_tA96EugjVxuC4nV966cLBK9xb7NBqfqv3q3oA6I0";

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY);

// Data sync utilities
export async function syncPatientsToSupabase(patients: any[]) {
  if (!patients || patients.length === 0) return { count: 0, error: null };
  
  const formatted = patients.map(patient => ({
    patient_id: patient.patientId,
    name: patient.name,
    phone: patient.phone,
    dob: patient.dob,
    notes: patient.notes,
    created_at: patient.createdAt
  }));
  
  const { data, error } = await supabase
    .from('patients')
    .upsert(formatted, { onConflict: 'patient_id' })
    .select();
    
  return { count: data?.length || 0, error };
}

export async function syncInvoicesToSupabase(invoices: any[]) {
  if (!invoices || invoices.length === 0) return { count: 0, error: null };
  
  const formatted = invoices.map(invoice => ({
    invoice_id: invoice.invoiceId,
    patient_id: invoice.patientId,
    patient_name: invoice.patientName,
    patient_phone: invoice.patientPhone,
    
    invoice_type: invoice.invoiceType,
    
    lens_type: invoice.lensType,
    lens_price: invoice.lensPrice,
    
    coating: invoice.coating,
    coating_price: invoice.coatingPrice,
    
    frame_brand: invoice.frameBrand,
    frame_model: invoice.frameModel,
    frame_color: invoice.frameColor,
    frame_size: invoice.frameSize,
    frame_price: invoice.framePrice,
    
    service_name: invoice.serviceName,
    service_id: invoice.serviceId,
    service_description: invoice.serviceDescription,
    service_price: invoice.servicePrice,
    
    discount: invoice.discount,
    deposit: invoice.deposit,
    total: invoice.total,
    remaining: invoice.remaining,
    
    payment_method: invoice.paymentMethod,
    auth_number: invoice.authNumber,
    work_order_id: invoice.workOrderId,
    
    created_at: invoice.createdAt,
    is_paid: invoice.isPaid,
    is_picked_up: invoice.isPickedUp,
    picked_up_at: invoice.pickedUpAt,
    
    is_refunded: invoice.isRefunded,
    refund_date: invoice.refundDate,
    refund_amount: invoice.refundAmount,
    refund_reason: invoice.refundReason,
    refund_method: invoice.refundMethod,
    refund_id: invoice.refundId,
    
    is_archived: invoice.isArchived,
    archived_at: invoice.archivedAt,
    archive_reason: invoice.archiveReason
  }));
  
  const { data, error } = await supabase
    .from('invoices')
    .upsert(formatted, { onConflict: 'invoice_id' })
    .select();
    
  // Sync payment records for each invoice
  for (const invoice of invoices) {
    if (invoice.payments && invoice.payments.length > 0) {
      await syncInvoicePaymentsToSupabase(invoice.invoiceId, invoice.payments);
    }
  }
    
  return { count: data?.length || 0, error };
}

export async function syncInvoicePaymentsToSupabase(invoiceId: string, payments: any[]) {
  if (!payments || payments.length === 0) return { count: 0, error: null };
  
  const formatted = payments.map(payment => ({
    invoice_id: invoiceId,
    amount: payment.amount,
    method: payment.method,
    date: payment.date,
    auth_number: payment.authNumber
  }));
  
  const { data, error } = await supabase
    .from('invoice_payments')
    .upsert(formatted, { 
      onConflict: 'invoice_id,date,amount,method' 
    })
    .select();
    
  return { count: data?.length || 0, error };
}

export async function syncWorkOrdersToSupabase(workOrders: any[]) {
  if (!workOrders || workOrders.length === 0) return { count: 0, error: null };
  
  const formatted = workOrders.map(order => ({
    work_order_id: order.id,
    patient_id: order.patientId,
    created_at: order.createdAt,
    
    lens_type_name: order.lensType?.name,
    lens_type_price: order.lensType?.price,
    
    is_picked_up: order.isPickedUp,
    picked_up_at: order.pickedUpAt,
    
    last_edited_at: order.lastEditedAt,
    
    is_refunded: order.isRefunded,
    refund_date: order.refundDate,
    
    is_archived: order.isArchived,
    archived_at: order.archivedAt,
    archive_reason: order.archiveReason
  }));
  
  const { data, error } = await supabase
    .from('work_orders')
    .upsert(formatted, { onConflict: 'work_order_id' })
    .select();
    
  return { count: data?.length || 0, error };
}

export async function syncRefundsToSupabase(refunds: any[]) {
  if (!refunds || refunds.length === 0) return { count: 0, error: null };
  
  const formatted = refunds.map(refund => ({
    refund_id: refund.refundId,
    amount: refund.amount,
    method: refund.method,
    date: refund.date,
    reason: refund.reason,
    staff_notes: refund.staffNotes,
    associated_invoice_id: refund.associatedInvoiceId
  }));
  
  const { data, error } = await supabase
    .from('refunds')
    .upsert(formatted, { onConflict: 'refund_id' })
    .select();
    
  return { count: data?.length || 0, error };
}

export async function syncFramesToSupabase(frames: any[]) {
  if (!frames || frames.length === 0) return { count: 0, error: null };
  
  const formatted = frames.map(frame => ({
    frame_id: frame.frameId,
    brand: frame.brand,
    model: frame.model,
    color: frame.color,
    size: frame.size,
    price: frame.price,
    qty: frame.qty,
    created_at: frame.createdAt
  }));
  
  const { data, error } = await supabase
    .from('frames')
    .upsert(formatted, { onConflict: 'frame_id' })
    .select();
    
  return { count: data?.length || 0, error };
}

export async function syncLensTypesToSupabase(lensTypes: any[]) {
  if (!lensTypes || lensTypes.length === 0) return { count: 0, error: null };
  
  const formatted = lensTypes.map(lens => ({
    lens_id: lens.id,
    name: lens.name,
    type: lens.type,
    price: lens.price
  }));
  
  const { data, error } = await supabase
    .from('lens_types')
    .upsert(formatted, { onConflict: 'lens_id' })
    .select();
    
  return { count: data?.length || 0, error };
}

export async function syncLensCoatingsToSupabase(coatings: any[]) {
  if (!coatings || coatings.length === 0) return { count: 0, error: null };
  
  const formatted = coatings.map(coating => ({
    coating_id: coating.id,
    name: coating.name,
    price: coating.price,
    description: coating.description,
    category: coating.category
  }));
  
  const { data, error } = await supabase
    .from('lens_coatings')
    .upsert(formatted, { onConflict: 'coating_id' })
    .select();
    
  return { count: data?.length || 0, error };
}

export async function syncLensThicknessesToSupabase(thicknesses: any[]) {
  if (!thicknesses || thicknesses.length === 0) return { count: 0, error: null };
  
  const formatted = thicknesses.map(thickness => ({
    thickness_id: thickness.id,
    name: thickness.name,
    price: thickness.price,
    description: thickness.description,
    category: thickness.category
  }));
  
  const { data, error } = await supabase
    .from('lens_thicknesses')
    .upsert(formatted, { onConflict: 'thickness_id' })
    .select();
    
  return { count: data?.length || 0, error };
}

export async function syncLensPricingCombinationsToSupabase(combinations: any[]) {
  if (!combinations || combinations.length === 0) return { count: 0, error: null };
  
  const formatted = combinations.map(combo => ({
    combination_id: combo.id,
    lens_type_id: combo.lensTypeId,
    coating_id: combo.coatingId,
    thickness_id: combo.thicknessId,
    price: combo.price
  }));
  
  const { data, error } = await supabase
    .from('lens_pricing_combinations')
    .upsert(formatted, { onConflict: 'combination_id' })
    .select();
    
  return { count: data?.length || 0, error };
}

export async function syncContactLensesToSupabase(contactLenses: any[]) {
  if (!contactLenses || contactLenses.length === 0) return { count: 0, error: null };
  
  const formatted = contactLenses.map(lens => ({
    lens_id: lens.id,
    brand: lens.brand,
    type: lens.type,
    bc: lens.bc,
    diameter: lens.diameter,
    power: lens.power,
    color: lens.color,
    price: lens.price,
    qty: lens.qty
  }));
  
  const { data, error } = await supabase
    .from('contact_lenses')
    .upsert(formatted, { onConflict: 'lens_id' })
    .select();
    
  return { count: data?.length || 0, error };
}

export async function syncServicesToSupabase(services: any[]) {
  if (!services || services.length === 0) return { count: 0, error: null };
  
  const formatted = services.map(service => ({
    service_id: service.id,
    name: service.name,
    description: service.description,
    price: service.price,
    category: service.category
  }));
  
  const { data, error } = await supabase
    .from('services')
    .upsert(formatted, { onConflict: 'service_id' })
    .select();
    
  return { count: data?.length || 0, error };
}

// Patient RX and Notes Sync Functions
export async function syncPatientRxToSupabase(patientId: string, rxData: any[]) {
  if (!rxData || rxData.length === 0) return { count: 0, error: null };
  
  const formatted = rxData.map(rx => ({
    patient_id: patientId,
    sphere_od: rx.sphereOD,
    cyl_od: rx.cylOD,
    axis_od: rx.axisOD,
    add_od: rx.addOD,
    sphere_os: rx.sphereOS,
    cyl_os: rx.cylOS,
    axis_os: rx.axisOS,
    add_os: rx.addOS,
    pd_right: rx.pdRight,
    pd_left: rx.pdLeft,
    created_at: rx.createdAt || new Date().toISOString()
  }));
  
  const { data, error } = await supabase
    .from('patient_rx')
    .upsert(formatted)
    .select();
    
  return { count: data?.length || 0, error };
}

export async function syncPatientNotesToSupabase(patientId: string, notes: any[]) {
  if (!notes || notes.length === 0) return { count: 0, error: null };
  
  const formatted = notes.map(note => ({
    patient_id: patientId,
    note_id: note.id,
    text: note.text,
    created_at: note.createdAt
  }));
  
  const { data, error } = await supabase
    .from('patient_notes')
    .upsert(formatted, { onConflict: 'note_id' })
    .select();
    
  return { count: data?.length || 0, error };
}

export async function syncContactLensRxToSupabase(patientId: string, rxData: any[]) {
  if (!rxData || rxData.length === 0) return { count: 0, error: null };
  
  const formatted = rxData.map(rx => ({
    patient_id: patientId,
    right_eye_sphere: rx.rightEye?.sphere,
    right_eye_cylinder: rx.rightEye?.cylinder,
    right_eye_axis: rx.rightEye?.axis,
    right_eye_bc: rx.rightEye?.bc,
    right_eye_dia: rx.rightEye?.dia,
    left_eye_sphere: rx.leftEye?.sphere,
    left_eye_cylinder: rx.leftEye?.cylinder,
    left_eye_axis: rx.leftEye?.axis,
    left_eye_bc: rx.leftEye?.bc,
    left_eye_dia: rx.leftEye?.dia,
    created_at: rx.createdAt || new Date().toISOString()
  }));
  
  const { data, error } = await supabase
    .from('patient_contact_lens_rx')
    .upsert(formatted)
    .select();
    
  return { count: data?.length || 0, error };
}
